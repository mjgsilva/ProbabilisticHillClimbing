#include <stdio.h>
#include <stdlib.h>
#include "hc.h"
#include "solution.h"
#include "utils.h"

/*
    HillClimbing algorithm - Accepting just a better new solution
    Param: solution generated by firstSolGen
    Returns the best solution found
*/

int hillClimbing(int sol[], int **matrix, int M, int G, int iters, int swap)
{
    int *newSol;
    int i;
    int totalSol, totalNewSol;
    
    newSol = (int *)malloc(M * sizeof(int));
    
    if(!newSol)
        exit(1);
    
    totalSol = calFitness(sol, matrix, M, G);
    
    for(i=0; i<iters; i++)
    {
        neighbouringGen(sol, newSol, M, G, swap);
        
        totalNewSol = calFitness(newSol, matrix, M, G);
        
        if(totalNewSol > totalSol)
        {
            copySol(newSol, sol, M);
            totalSol = totalNewSol;
        }
    }
    
    free(newSol);
    
    return totalSol;
}

/*
 Probabilistic HillClimbing algorithm - Accepting better, equal and sometimes (param prob)
 a worst new solution to avoid local maximum
 Param: solution generated by firstSolGen
 Returns the best solution found
 */

int hillClimbingProb(int sol[], int **matrix, int M, int G, int iters, int swap, float prob)
{
    int *newSol, *bestSol;
    int i; double rnd;
    int totalSol, totalNewSol, totalBestSol;
    
    newSol = (int *)malloc(M * sizeof(int));
    bestSol = (int *)malloc(M * sizeof(int));
    
    if(!newSol || !bestSol)
        exit(1);
    
    copySol(sol, bestSol, M);
    totalSol = calFitness(sol, matrix, M, G);
    totalBestSol = totalSol;
    
    for(i=0; i<iters; i++)
    {
        neighbouringGen(sol, newSol, M, G, swap);
        
        totalNewSol = calFitness(newSol, matrix, M, G);
        
        if(totalNewSol >= totalSol)
        {
            copySol(newSol, sol, M);
            totalSol = totalNewSol;
        }
        else
        {
            rnd = randFloatGen();
            if (rnd < prob)
            {
                copySol(newSol, sol, M);
                totalSol = totalNewSol;
            }
        }
        
        if(totalBestSol < totalSol)
        {
            copySol(sol, bestSol, M);
            totalBestSol = totalSol;
        }
    }
    
    copySol(bestSol, sol, M);
    totalSol = totalBestSol;
    
    
    free(newSol);
    free(bestSol);
    
    return totalSol;
}